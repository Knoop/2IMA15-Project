/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package voronoigame.view;

import java.util.Observable;
import java.util.Observer;
import java.util.Timer;
import java.util.TimerTask;
import voronoigame.controller.GameController;
import voronoigame.model.GameState;

/**
 *
 * @author Maurice
 */
public class GamePanel extends ContentPanel implements Observer {

    /**
     * The refresh rate of the gamepanel expressed in Hz. The actual refresh
     * rate should be as close as possible to this value.
     */
    public static final int REFRESH_RATE = 60;

    /**
     * The minimum amount of time in milliseconds between every rendition. The
     * value is equal to 1000 milliseconds divided by the refresh rate defined
     * by {@code REFRESH_RATE}. The actual amount of time between renditions
     * should be as close to this as possible.
     */
    private static final long REFRESH_INTERVAL = 1000l / REFRESH_RATE;

    private GameController gameController;

    /**
     *
     */
    private Timer renderTimer;
    /**
     * Indicates whether the gamestate has changed since the previous rendition
     */
    private boolean changed;

    /**
     * Indicates whether the rendering is paused. At the start the rendering
     * must be started, and therefore is seen as being paused.
     */
    private boolean pauseRendering = true;

    GamePanel(GameState gameState, MainView parent) {
        super(parent);
        initComponents();
        this.setupGame(gameState);
    }

    private void setupGame(GameState gameState) {
        gameState.addObserver(this);
        this.voronoiPanel.setGameState(gameState);
        this.gameController = new GameController(gameState);
        this.voronoiPanel.addMouseListener(this.gameController);
        this.voronoiPanel.addMouseMotionListener(this.gameController);
        this.voronoiPanel.repaint();
        this.start();
    }

    /**
     * Stop rendering
     */
    public void pause() {
        this.pauseRendering = true;
        this.renderTimer.cancel();
    }

    /**
     * Start rendering
     */
    public void start() {
        if (!this.pauseRendering) {
            return;
        }

        this.pauseRendering = false;
        this.renderTimer = new Timer();
        this.renderTimer.schedule(new RenderTimerTask(), REFRESH_INTERVAL);
    }

    /**
     * Resume rendering
     */
    public void resume() {
        this.start();
    }

    private void updatePanel() {
        this.voronoiPanel.repaint();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        menuContainer = new javax.swing.JPanel();
        stopButton = new javax.swing.JButton();
        nextButton = new javax.swing.JButton();
        voronoiPanel = new voronoigame.view.voronoi.VoronoiPanel();

        setLayout(new java.awt.BorderLayout());

        menuContainer.setMaximumSize(new java.awt.Dimension(32767, 100));
        menuContainer.setLayout(new java.awt.GridLayout(1, 0));

        stopButton.setText("stop");
        stopButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stopButtonActionPerformed(evt);
            }
        });
        menuContainer.add(stopButton);

        nextButton.setText("next");
        nextButton.setEnabled(false);
        nextButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextButtonActionPerformed(evt);
            }
        });
        menuContainer.add(nextButton);

        add(menuContainer, java.awt.BorderLayout.PAGE_END);

        javax.swing.GroupLayout voronoiPanelLayout = new javax.swing.GroupLayout(voronoiPanel);
        voronoiPanel.setLayout(voronoiPanelLayout);
        voronoiPanelLayout.setHorizontalGroup(
            voronoiPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        voronoiPanelLayout.setVerticalGroup(
            voronoiPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 277, Short.MAX_VALUE)
        );

        add(voronoiPanel, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    private void nextButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextButtonActionPerformed
        this.parent.nextLevel();
    }//GEN-LAST:event_nextButtonActionPerformed

    private void stopButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopButtonActionPerformed
        this.parent.endLevel();
    }//GEN-LAST:event_stopButtonActionPerformed

    @Override
    protected void onPanelAdded() {
    }

    @Override
    protected void onPanelRemoved() {
        this.gameController.stop();
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel menuContainer;
    private javax.swing.JButton nextButton;
    private javax.swing.JButton stopButton;
    private voronoigame.view.voronoi.VoronoiPanel voronoiPanel;
    // End of variables declaration//GEN-END:variables

    @Override
    public void update(Observable o, Object arg) {
        this.changed = true;
        if(((GameState) o).isFinished())
            this.endGame((GameState)o);
    }

    private void endGame(GameState gameState) {
        this.gameController.stop();
        this.pause();
        this.parent.showLevelCompleted(gameState);
        // If won, allow to go to the next level
        if(gameState.hasWon())
            this.nextButton.setEnabled(true);
        this.updatePanel();
    }

    private class RenderTimerTask extends TimerTask {

        @Override
        public void run() {
            long start = System.currentTimeMillis();
            if (GamePanel.this.changed) {
                GamePanel.this.changed = false;
                GamePanel.this.updatePanel();
            }

            if (!GamePanel.this.pauseRendering) {
                GamePanel.this.renderTimer.schedule(new RenderTimerTask(), GamePanel.REFRESH_INTERVAL - (System.currentTimeMillis() - start));
            }

        }

    }

}
